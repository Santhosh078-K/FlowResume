# app.py
import streamlit as st
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders
import pdfkit # Already imported, but ensure it's there
from tempfile import NamedTemporaryFile
import markdown # Already imported, but ensure it's there
import os
import datetime # Import datetime for timestamp in PDF footer

# Import functions from our new modules
from config import WKHTMLTOPDF_PATH, SENDER_EMAIL, GMAIL_APP_PASSWORD, ADMIN_PASS, DB_FILE,POPPLER_PATH# Added DB_FILE
from db_operations import load_db_data, save_db_data, record_interaction, clean_old_history
from ai_service import (
    analyze_resume, get_match_score, optimize_resume, check_grammar,
    keyword_density, suggest_roles, section_check, generate_cover_letter,
    salary_insights, skill_gap_analysis, generate_interview_questions,
    generate_branding_statement
)
from utils import pdf_to_base64_images, sanitize_filename, generate_pdf_from_markdown # Added generate_pdf_from_markdown


# --- Email Function (Moved here from previous full code) ---
def send_email_with_pdf(recipient_email, pdf_data, filename="Optimized_Resume.pdf"):
    """
    Sends an email with a PDF attachment.
    """
    sender_email = SENDER_EMAIL
    sender_password = GMAIL_APP_PASSWORD

    if not sender_password:
        st.error("Gmail App Password not found. Please set GMAIL_APP_PASSWORD in your .env file.")
        return False

    subject = "Your Optimized Resume - AI Evaluation from ResumeFlow AI"

    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = recipient_email
    msg['Subject'] = subject
    body = """
    Dear Applicant,

    Please find attached your optimized resume, generated by our AI-Powered ResumeFlow AI.
    We hope this helps you in your job search!

    Best regards,
    ResumeFlow AI Team
    """
    msg.attach(MIMEText(body, 'plain'))

    # Attach PDF data
    part = MIMEMultipart() # Use MIMEMultipart for outer boundary
    part = MIMEBase('application', 'octet-stream') # Reset part to MIMEBase for binary attachment
    part.set_payload(pdf_data)
    encoders.encode_base64(part) # Encode the attachment in base64
    part.add_header('Content-Disposition', f"attachment; filename= {filename}")
    msg.attach(part)

    try:
        # Connect to Gmail's SMTP server
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls() # Enable TLS encryption
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, msg.as_string())
        server.quit()
        st.success(f"Optimized resume sent successfully to {recipient_email}!")
        return True
    except smtplib.SMTPAuthenticationError:
        st.error("Failed to send email: Authentication Error. Please check your Gmail App Password and ensure it's correct.")
        st.info("You might need to generate an App Password for your Google account if 2FA is enabled. See Google's documentation for 'App passwords'.")
        return False
    except smtplib.SMTPConnectError as e:
        st.error(f"Failed to send email: Connection Error. Please check your internet connection or firewall settings. Error: {e}")
        return False
    except Exception as e:
        st.error(f"Failed to send email. An unexpected error occurred: {e}")
        return False

# --- Streamlit UI ---

st.set_page_config(page_title="üöÄ ResumeFlow AI - Smart Resume Evaluator", layout="wide")
st.title("‚ú® ResumeFlow AI")
st.markdown("Unlock your resume's full potential with intelligent AI analysis and optimization.")

st.sidebar.header("Navigation")
user_type = st.sidebar.selectbox("Select User Type", ["Applicant", "Admin"])

# Initialize session state for job description if it doesn't exist
if 'job_description_text_area' not in st.session_state:
    st.session_state.job_description_text_area = ""
if 'optimized_resume_markdown' not in st.session_state:
    st.session_state.optimized_resume_markdown = ""

# Function to update job description text area from examples
def set_job_description_example(example_text):
    st.session_state.job_description_text_area = example_text

if user_type == "Applicant":
    st.header("Applicant Portal")
    st.subheader("Your AI-Powered Resume Assistant")

    user_name = st.text_input("üë§ Your Name:", help="Enter your full name. This will be used for your optimized resume filename.", key="user_name_input")
    user_email = st.text_input("üìß Your Email (for optimized resume delivery):", help="Enter your email to receive the AI-optimized resume as a PDF.", key="user_email_input")

    col_input, col_upload = st.columns([2,1])
    with col_input:
        st.markdown("### üìÑ Paste the Job Description Here:")
        job_desc_input = st.text_area(
            "_", # Label is hidden, using markdown for heading
            height=250,
            placeholder="E.g., 'Senior Software Engineer: Develop scalable applications in Python, experience with AWS, Docker, Kubernetes...'",
            help="Provide the complete job description to tailor the AI analysis.",
            value=st.session_state.job_description_text_area, # Use session state for value
            key="job_description_text_area_key" # Assign a key to manage in session state
        )

        st.markdown("---")
        st.markdown("### Or Select a Job Description Example:")

        job_examples = {
            "Software Engineer": """
            Job Title: Software Engineer
            Company: Tech Innovations Inc.
            Location: Bengaluru, India

            Responsibilities:
            - Design, develop, and maintain high-performance, scalable software solutions.
            - Collaborate with cross-functional teams to define, design, and ship new features.
            - Write clean, maintainable, and efficient code in Python, Java, or Go.
            - Participate in code reviews and contribute to architectural discussions.
            - Debug and resolve technical issues.

            Qualifications:
            - Bachelor's or Master's degree in Computer Science or related field.
            - 3+ years of experience in software development.
            - Strong proficiency in data structures and algorithms.
            - Experience with cloud platforms (AWS, Azure, GCP) is a plus.
            - Familiarity with agile development methodologies.
            """,
            "Digital Marketing Specialist": """
            Job Title: Digital Marketing Specialist
            Company: Brand Growth Agency
            Location: Mumbai, India

            Responsibilities:
            - Develop and implement digital marketing strategies across various channels (SEO, SEM, social media, email marketing).
            - Manage and optimize paid advertising campaigns (Google Ads, Facebook Ads).
            - Analyze campaign performance using tools like Google Analytics and provide actionable insights.
            - Create engaging content for social media and website.
            - Stay up-to-date with the latest digital marketing trends and best practices.

            Qualifications:
            - Bachelor's degree in Marketing, Communications, or a related field.
            - 2+ years of experience in digital marketing.
            - Proven track record of successful SEO/SEM campaigns.
            - Strong analytical skills and experience with marketing analytics tools.
            - Excellent written and verbal communication skills.
            """,
            "Data Analyst": """
            Job Title: Data Analyst
            Company: Global Analytics Solutions
            Location: Hyderabad, India

            Responsibilities:
            - Collect, clean, and interpret data from various sources.
            - Develop and implement databases, data collection systems, data analytics and other strategies that optimize statistical efficiency and quality.
            - Identify, analyze, and interpret trends or patterns in complex data sets.
            - Work with management to prioritize business and information needs.
            - Create visualizations and reports to communicate findings effectively.

            Qualifications:
            - Bachelor's degree in Mathematics, Statistics, Computer Science, or a related field.
            - 1-3 years of experience as a Data Analyst or in a similar role.
            - Strong knowledge of SQL and Excel.
            - Experience with data visualization tools (e.g., Tableau, Power BI).
            - Proficiency in statistical programming languages (R or Python) is a plus.
            """
        }

        example_cols = st.columns(len(job_examples))
        for i, (name, text) in enumerate(job_examples.items()):
            with example_cols[i]:
                if st.button(name, key=f"example_btn_{i}", use_container_width=True):
                    set_job_description_example(text)

    with col_upload:
        uploaded_resume = st.file_uploader("‚¨ÜÔ∏è **Upload Your Resume (PDF):**", type=["pdf"],
                                         help="Upload your resume in PDF format. AI will analyze the visual layout and text.")

    # Advanced Options
    with st.expander("‚öôÔ∏è **Advanced Options & Configuration**"):
        st.markdown("---")
        st.subheader("Model & Processing Settings")
        model_choice = st.selectbox(
            "Select Gemini Model:",
            ('gemini-1.5-flash', 'gemini-1.5-pro'),
            index=0, # Default to 'gemini-1.5-flash'
            help="Choose 'gemini-1.5-flash' for faster responses (default) or 'gemini-1.5-pro' for more comprehensive analysis (may be slower/costlier)."
        )
        pages_to_analyze = st.slider(
            "Number of Resume Pages to Analyze (as images):",
            1, 3, 1, # Min 1, Max 3, Default 1
            help="Increasing pages increases AI processing time and token usage. 1-2 pages are usually sufficient for summary."
        )
        st.markdown("---")
        st.subheader("Optional Inputs for Specific Tools")
        company_name_cl = st.text_input("Company Name (for Cover Letter):", help="Optional: Provide company name for a personalized cover letter.")
        hiring_manager_cl = st.text_input("Hiring Manager (for Cover Letter, if known):", help="Optional: Provide hiring manager's name for a more personal touch.")
        output_language_opt = st.text_input("Output Language (for Optimized Resume, e.g., 'English'):", "English",
                                             help="Optional: Specify the language for the optimized resume output.")
        location_salary = st.text_input("Location (for Salary Insights, e.g., 'Coimbatore, India'):",
                                         help="Optional: Provide a location for more accurate salary insights.")
        experience_salary = st.text_input("Experience Level (for Salary Insights, e.g., 'Mid-level'):",
                                          help="Optional: Specify experience level for refined salary insights.")
        branding_target_role = st.text_input("Target Role Type (for Branding Statement):", help="E.g., 'Software Developer', 'Marketing Manager'")
        st.markdown("---")

    # Convert PDF to parts for Gemini only when a file is uploaded
    pdf_image_parts = []
    if uploaded_resume:
        with st.spinner("Processing PDF for AI analysis..."):
            pdf_image_parts = pdf_to_base64_images(uploaded_resume, pages_to_analyze)
            if not pdf_image_parts:
                st.error("Failed to process resume. Please ensure it's a valid PDF and not just a scanned image.")
            else:
                st.success(f"Ready to analyze {len(pdf_image_parts)} page(s) of your resume using '{model_choice}'.")

    st.markdown("---")
    st.subheader("Choose an Analysis Option:")
    col1, col2, col3, col4 = st.columns(4) # Added a column for new features

    with col1:
        btn_review = st.button("üîç Comprehensive Review", use_container_width=True, help="Receive detailed feedback from an AI HR manager.")
        btn_grammar = st.button("üìù Grammar & Language Check", use_container_width=True, help="Get corrections and improvements for your resume's text.")
        btn_sections = st.button("üìã Section Completeness Check", use_container_width=True, help="Evaluate if your resume has all essential sections and their quality.")
    with col2:
        btn_match = st.button("üìä ATS Match Score", use_container_width=True, help="See your resume's match percentage with the job description, like an ATS.")
        btn_keywords = st.button("üîë Keyword Density Analysis", use_container_width=True, help="Find out which keywords are matched/missing and how to optimize.")
        btn_roles = st.button("üéØ Suggest Job Roles", use_container_width=True, help="Based on your resume, get suggestions for suitable job roles and career paths.")
    with col3:
        btn_optimize_email = st.button("‚ú® Generate & Email Improved Resume", use_container_width=True, help="Get an AI-optimized resume and have it emailed to you as a PDF.")
        btn_cover_letter = st.button("üíå Generate Cover Letter", use_container_width=True, help="Create a tailored cover letter based on your resume and job description.")
        btn_salary = st.button("üí∞ Salary Insights", use_container_width=True, help="Get estimated salary ranges and market insights for your profile.")
    with col4: # New column for new features
        btn_skill_gap = st.button("üí° Skill Gap Analysis", use_container_width=True, help="Identify missing skills and get learning path suggestions for specific jobs.")
        btn_interview_q = st.button("üó£Ô∏è Interview Prep Questions", use_container_width=True, help="Generate tailored interview questions based on your resume and job description.")
        btn_branding = st.button("üåü Personal Branding Statement", use_container_width=True, help="Get professional headlines and summaries for your resume or LinkedIn.")


    # --- Button Logic ---
    current_job_desc_input = st.session_state.job_description_text_area_key # Get the current value from session state

    if btn_review:
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Analyzing resume for HR feedback..."):
                response = analyze_resume(current_job_desc_input, pdf_image_parts, model_choice)
            st.subheader("üìã **Comprehensive Resume Analysis:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Comprehensive Review", current_job_desc_input, response)
            # --- Download Button for Comprehensive Review ---
            if response:
                pdf_data_review = generate_pdf_from_markdown(response,
                                                           title=f"Comprehensive Resume Analysis for {user_name}",
                                                           filename=f"{sanitize_filename(user_name)}_Resume_Analysis.pdf")
                if pdf_data_review:
                    st.download_button(
                        label="Download Analysis as PDF",
                        data=pdf_data_review,
                        file_name=f"{sanitize_filename(user_name)}_Resume_Analysis.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and paste/select a job description for a Comprehensive Review.")

    elif btn_match:
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Calculating ATS match percentage..."):
                response = get_match_score(current_job_desc_input, pdf_image_parts, model_choice)
            st.subheader("üìä **ATS Match Score & Analysis:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "ATS Match Score", current_job_desc_input, response)
            # --- Download Button for ATS Match Score ---
            if response:
                pdf_data_ats = generate_pdf_from_markdown(response,
                                                        title=f"ATS Match Score for {user_name}",
                                                        filename=f"{sanitize_filename(user_name)}_ATS_Match_Report.pdf")
                if pdf_data_ats:
                    st.download_button(
                        label="Download ATS Report as PDF",
                        data=pdf_data_ats,
                        file_name=f"{sanitize_filename(user_name)}_ATS_Match_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and paste/select the job description for ATS Match Score analysis.")

    elif btn_optimize_email:
        if uploaded_resume and current_job_desc_input and user_email and user_name and pdf_image_parts:
            with st.spinner("Generating initial optimized resume draft..."):
                # Generate the initial optimized markdown
                initial_optimized_markdown = optimize_resume(current_job_desc_input, pdf_image_parts, output_language_opt, model_choice)
                st.session_state.optimized_resume_markdown = initial_optimized_markdown # Store in session state for editing

            st.subheader("‚ú® **Your AI-Optimized Resume Draft (Edit Below):**")
            # Editable text area for the user to refine the AI-generated content
            edited_resume_markdown = st.text_area(
                "Review and edit the AI-generated resume markdown:",
                value=st.session_state.optimized_resume_markdown,
                height=500,
                key="editable_optimized_resume_content"
            )

            if st.button("Generate Final PDF & Email", help="Generates a PDF from your edited content and emails it."):
                if edited_resume_markdown.strip() == "":
                    st.warning("Edited resume content cannot be empty. Please review or regenerate.")
                else:
                    with st.spinner("Finalizing PDF and sending email..."):
                        # Generate dynamic filename
                        sanitized_name = sanitize_filename(user_name)
                        download_filename = f"{sanitized_name}_Optimized_Resume.pdf"

                        # Convert edited markdown to HTML (using the existing method for optimized resume)
                        # The generate_pdf_from_markdown function can also be used here for consistency if needed.
                        # For now, keeping the existing specific HTML structure for optimized resume.
                        html_content = markdown.markdown(edited_resume_markdown)
                        temp_html_content = f"""
                        <!DOCTYPE html>
                        <html>
                        <head>
                            <meta charset="utf-8">
                            <title>{user_name} - Optimized Resume</title>
                            <style>
                                body {{ font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; padding: 20px; }}
                                h1, h2, h3 {{ color: #2c3e50; }}
                                h1 {{ font-size: 2em; text-align: center; }}
                                h2 {{ font-size: 1.5em; border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-top: 20px; }}
                                ul {{ list-style-type: disc; margin-left: 20px; }}
                                b {{ font-weight: bold; }}
                                /* Additional styles for resume aesthetics can go here */
                            </style>
                        </head>
                        <body>
                            {html_content}
                        </body>
                        </html>
                        """

                        try:
                            config = None
                            if WKHTMLTOPDF_PATH:
                                config = pdfkit.configuration(wkhtmltopdf=WKHTMLTOPDF_PATH)

                            with NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_pdf:
                                if config:
                                    pdfkit.from_string(temp_html_content, tmp_pdf.name, configuration=config)
                                else:
                                    pdfkit.from_string(temp_html_content, tmp_pdf.name)
                                tmp_pdf.seek(0)
                                pdf_data = tmp_pdf.read()

                            if send_email_with_pdf(user_email, pdf_data, filename=download_filename): # Pass dynamic filename
                                st.download_button(
                                    label="Download Optimized Resume",
                                    data=pdf_data,
                                    file_name=download_filename, # Use dynamic filename for download
                                    mime="application/pdf"
                                )
                                record_interaction(user_name, user_email, "Optimized Resume & Email", current_job_desc_input, edited_resume_markdown)
                            os.unlink(tmp_pdf.name) # Clean up the temporary PDF file
                        except Exception as e:
                            st.error(f"Error generating or sending PDF: {e}. Please ensure 'wkhtmltopdf' is installed and in your system's PATH, or configure WKHTMLTOPDF_PATH in the script. For Windows, explicitly set `WKHTMLTOPDF_PATH`.")
        else:
            st.warning("Please upload a resume, paste/select the job description, enter your name, and email to generate and email the improved resume.")

    elif btn_grammar:
        if uploaded_resume and pdf_image_parts:
            with st.spinner("Checking grammar and language..."):
                response = check_grammar(pdf_image_parts, model_choice)
            st.subheader("üìù **Grammar & Language Check:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Grammar Check", "", response) # No job_desc for this type
            # --- Download Button for Grammar Check ---
            if response:
                pdf_data_grammar = generate_pdf_from_markdown(response,
                                                            title=f"Grammar & Language Check for {user_name}",
                                                            filename=f"{sanitize_filename(user_name)}_Grammar_Report.pdf")
                if pdf_data_grammar:
                    st.download_button(
                        label="Download Grammar Report as PDF",
                        data=pdf_data_grammar,
                        file_name=f"{sanitize_filename(user_name)}_Grammar_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume to perform a Grammar & Language Check.")

    elif btn_keywords:
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Analyzing keyword density..."):
                response = keyword_density(current_job_desc_input, pdf_image_parts, model_choice)
            st.subheader("üîë **Keyword Density Analysis:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Keyword Density Analysis", current_job_desc_input, response)
            # --- Download Button for Keyword Density ---
            if response:
                pdf_data_keywords = generate_pdf_from_markdown(response,
                                                             title=f"Keyword Density Analysis for {user_name}",
                                                             filename=f"{sanitize_filename(user_name)}_Keyword_Report.pdf")
                if pdf_data_keywords:
                    st.download_button(
                        label="Download Keyword Report as PDF",
                        data=pdf_data_keywords,
                        file_name=f"{sanitize_filename(user_name)}_Keyword_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and paste/select the job description for Keyword Analysis.")

    elif btn_roles:
        if uploaded_resume and pdf_image_parts:
            with st.spinner("Suggesting suitable job roles..."):
                response = suggest_roles(pdf_image_parts, model_choice)
            st.subheader("üéØ **Suggested Job Roles:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Suggested Job Roles", "", response) # No job_desc for this type
            # --- Download Button for Suggested Roles ---
            if response:
                pdf_data_roles = generate_pdf_from_markdown(response,
                                                          title=f"Suggested Job Roles for {user_name}",
                                                          filename=f"{sanitize_filename(user_name)}_Job_Roles_Report.pdf")
                if pdf_data_roles:
                    st.download_button(
                        label="Download Job Roles as PDF",
                        data=pdf_data_roles,
                        file_name=f"{sanitize_filename(user_name)}_Job_Roles_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume to suggest job roles.")

    elif btn_sections:
        if uploaded_resume and pdf_image_parts:
            with st.spinner("Checking resume sections..."):
                response = section_check(pdf_image_parts, model_choice)
            st.subheader("üìã **Section Completeness Check:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Section Check", "", response) # No job_desc for this type
            # --- Download Button for Section Check ---
            if response:
                pdf_data_sections = generate_pdf_from_markdown(response,
                                                             title=f"Resume Section Check for {user_name}",
                                                             filename=f"{sanitize_filename(user_name)}_Sections_Report.pdf")
                if pdf_data_sections:
                    st.download_button(
                        label="Download Sections Report as PDF",
                        data=pdf_data_sections,
                        file_name=f"{sanitize_filename(user_name)}_Sections_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume to perform a Section Completeness Check.")

    elif btn_cover_letter:
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Generating tailored cover letter..."):
                response = generate_cover_letter(current_job_desc_input, pdf_image_parts, company_name_cl, hiring_manager_cl, model_choice)
            st.subheader("üíå **Tailored Cover Letter:**")
            st.markdown(response)
            if user_email:
                record_interaction(user_name, user_email, "Generate Cover Letter", current_job_desc_input, response)
            # --- Download Button for Cover Letter ---
            if response:
                pdf_data_cl = generate_pdf_from_markdown(response,
                                                         title=f"Cover Letter for {user_name}",
                                                         filename=f"{sanitize_filename(user_name)}_Cover_Letter.pdf")
                if pdf_data_cl:
                    st.download_button(
                        label="Download Cover Letter as PDF",
                        data=pdf_data_cl,
                        file_name=f"{sanitize_filename(user_name)}_Cover_Letter.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and provide a Job Description to generate a Cover Letter.")

    elif btn_salary:
        if uploaded_resume and pdf_image_parts:
            with st.spinner("Generating salary insights..."):
                response = salary_insights(pdf_image_parts, location_salary, experience_salary, model_choice)
            st.subheader("üí∞ **Salary Insights:**")
            st.write(response)
            if user_email:
                record_interaction(user_name, user_email, "Salary Insights", "", response) # No job_desc for this type
            # --- Download Button for Salary Insights ---
            if response:
                pdf_data_salary = generate_pdf_from_markdown(response,
                                                            title=f"Salary Insights for {user_name}",
                                                            filename=f"{sanitize_filename(user_name)}_Salary_Insights.pdf")
                if pdf_data_salary:
                    st.download_button(
                        label="Download Salary Insights as PDF",
                        data=pdf_data_salary,
                        file_name=f"{sanitize_filename(user_name)}_Salary_Insights.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume to generate Salary Insights.")

    elif btn_skill_gap: # NEW FEATURE
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Performing skill gap analysis..."):
                response = skill_gap_analysis(pdf_image_parts, current_job_desc_input, model_choice)
            st.subheader("üí° **Skill Gap Analysis & Learning Paths:**")
            st.markdown(response)
            if user_email:
                record_interaction(user_name, user_email, "Skill Gap Analysis", current_job_desc_input, response)
            # --- Download Button for Skill Gap Analysis ---
            if response:
                pdf_data_skill_gap = generate_pdf_from_markdown(response,
                                                               title=f"Skill Gap Analysis for {user_name}",
                                                               filename=f"{sanitize_filename(user_name)}_Skill_Gap_Report.pdf")
                if pdf_data_skill_gap:
                    st.download_button(
                        label="Download Skill Gap Report as PDF",
                        data=pdf_data_skill_gap,
                        file_name=f"{sanitize_filename(user_name)}_Skill_Gap_Report.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and paste/select a job description for Skill Gap Analysis.")

    elif btn_interview_q: # NEW FEATURE
        if uploaded_resume and current_job_desc_input and pdf_image_parts:
            with st.spinner("Generating interview questions..."):
                response = generate_interview_questions(pdf_image_parts, current_job_desc_input, model_choice)
            st.subheader("üó£Ô∏è **Tailored Interview Questions:**")
            st.markdown(response)
            if user_email:
                record_interaction(user_name, user_email, "Interview Questions", current_job_desc_input, response)
            # --- Download Button for Interview Questions ---
            if response:
                pdf_data_interview = generate_pdf_from_markdown(response,
                                                                title=f"Interview Questions for {user_name}",
                                                                filename=f"{sanitize_filename(user_name)}_Interview_Questions.pdf")
                if pdf_data_interview:
                    st.download_button(
                        label="Download Interview Questions as PDF",
                        data=pdf_data_interview,
                        file_name=f"{sanitize_filename(user_name)}_Interview_Questions.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume and paste/select a job description to generate Interview Questions.")

    elif btn_branding: # NEW FEATURE
        if uploaded_resume and pdf_image_parts:
            with st.spinner("Generating personal branding statements..."):
                response = generate_branding_statement(pdf_image_parts, branding_target_role, model_choice)
            st.subheader("üåü **Personal Branding Statement:**")
            st.markdown(response)
            if user_email:
                record_interaction(user_name, user_email, "Personal Branding", "", response) # No job_desc for this type
            # --- Download Button for Personal Branding ---
            if response:
                pdf_data_branding = generate_pdf_from_markdown(response,
                                                               title=f"Personal Branding Statement for {user_name}",
                                                               filename=f"{sanitize_filename(user_name)}_Branding_Statement.pdf")
                if pdf_data_branding:
                    st.download_button(
                        label="Download Branding Statement as PDF",
                        data=pdf_data_branding,
                        file_name=f"{sanitize_filename(user_name)}_Branding_Statement.pdf",
                        mime="application/pdf"
                    )
        else:
            st.warning("Please upload a resume to generate a Personal Branding Statement.")

    st.markdown("---")
    st.subheader("Your Recent Interactions:") # Applicant's personal history
    if user_email:
        db_data = load_db_data()
        user_history = [
            entry for entry in db_data["history"]
            if entry.get("email") == user_email and entry.get("name") == user_name # Filter by both name and email
        ]
        if user_history:
            st.info(f"Displaying recent interactions for {user_name} ({user_email}):")
            for entry in reversed(user_history): # Show most recent first
                timestamp = entry.get('timestamp', 'N/A')
                analysis_type = entry.get('analysis_type', 'N/A')
                job_desc_excerpt = entry.get('job_description_excerpt', 'No JD provided')
                ai_response_excerpt = entry.get('ai_response_excerpt', 'No AI response')

                with st.expander(f"**{timestamp}** - **{analysis_type}**"):
                    if job_desc_excerpt != 'No JD provided':
                        st.write(f"**Job Description (excerpt):** {job_desc_excerpt}")
                    st.write(f"**AI Response (excerpt):** {ai_response_excerpt}")
        else:
            st.info("No recent interactions found for this user.")
    else:
        st.info("Enter your name and email to see your interaction history here.")


elif user_type == "Admin":
    st.header("Admin Panel")
    admin_pass = st.sidebar.text_input("Admin Password", type="password")

    if admin_pass and ADMIN_PASS and admin_pass == ADMIN_PASS:
        st.success("Welcome Admin!")

        db_data = load_db_data()

        # --- Automatic History Cleanup (100 days) ---
        if clean_old_history(db_data, days_threshold=100):
            st.success("Old history entries (older than 100 days) automatically cleared!")
            # Reload db_data after cleanup to reflect changes
            db_data = load_db_data()


        st.subheader("üìä System Metrics")

        # Calculate unique users safely
        valid_emails = set()
        if db_data["users"]:
            for user in db_data["users"]:
                # Ensure 'user' is a dictionary AND contains the 'email' key
                if isinstance(user, dict) and "email" in user:
                    valid_emails.add(user["email"])
        unique_users_count = len(valid_emails)
        st.metric(label="Total Unique Users (based on email)", value=unique_users_count)


        st.markdown("---")
        st.subheader("üìú Full User Interaction History") # Changed subheader

        if db_data["history"]:
            # Display history in reverse chronological order
            for entry in reversed(db_data["history"]):
                # Ensure all expected keys exist using .get() for robustness
                timestamp = entry.get('timestamp', 'N/A')
                analysis_type = entry.get('analysis_type', 'N/A')
                name = entry.get('name', 'Unknown User')
                email = entry.get('email', 'N/A')
                job_desc_excerpt = entry.get('job_description_excerpt', 'No JD provided')
                ai_response_excerpt = entry.get('ai_response_excerpt', 'No AI response')

                with st.expander(f"**{timestamp}** - **{analysis_type}** by **{name}** ({email})"):
                    if job_desc_excerpt != 'No JD provided':
                        st.write(f"**Job Description (excerpt):** {job_desc_excerpt}")
                    st.write(f"**AI Response (excerpt):** {ai_response_excerpt}")
        else:
            st.info("No user interaction history available yet.")

        st.markdown("---")
        st.subheader("‚ö†Ô∏è Admin Actions")

        # --- Clear All Data Button ---
        # Initialize session state for confirmation if not present
        if 'confirm_clear_data' not in st.session_state:
            st.session_state.confirm_clear_data = False

        if st.button("üóëÔ∏è Clear All Data (Users & History)", key="clear_all_button", help="Permanently deletes all stored user and interaction data from the database."):
            st.session_state.confirm_clear_data = True # Set confirmation state to True

        if st.session_state.confirm_clear_data:
            st.warning("Are you absolutely sure you want to delete ALL data? This action cannot be undone.")
            col_confirm_yes, col_confirm_no = st.columns(2)
            with col_confirm_yes:
                if st.button("Yes, Clear All Data", key="confirm_yes_button", use_container_width=True):
                    try:
                        empty_db = {"users": [], "history": []}
                        save_db_data(empty_db)
                        st.success("All user and history data has been cleared!")
                        st.session_state.confirm_clear_data = False # Reset confirmation
                        st.rerun() # Using st.rerun()
                    except Exception as e:
                        st.error(f"Error clearing data: {e}. Please ensure the application has write permissions to the '{DB_FILE}' file's directory.")
            with col_confirm_no:
                if st.button("No, Cancel", key="confirm_no_button", use_container_width=True):
                    st.info("Data clearing cancelled.")
                    st.session_state.confirm_clear_data = False # Reset confirmation
                    # st.rerun() # Optional: rerun to immediately hide confirmation message

        st.markdown("---")
        st.subheader("‚öôÔ∏è Current Configurations & Notes:")
        st.write(f"- Gemini API Key Status: {'Loaded' if os.getenv('GOOGLE_API_KEY') else 'Not Loaded'}")
        st.write(f"- Poppler Path: {POPPLER_PATH if POPPLER_PATH else 'Auto-detected (or not set)'}")
        st.write(f"- wkhtmltopdf Path: {WKHTMLTOPDF_PATH if WKHTMLTOPDF_PATH else 'Auto-detected (or not set)'}")
        st.write(f"- Email Sender: {SENDER_EMAIL}")
        st.write(f"- Email Password Status: {'Loaded' if GMAIL_APP_PASSWORD else 'Not Loaded'}")
        st.info("**Important Note on Data Persistence:** If you deploy this application to a cloud hosting service (like Streamlit Community Cloud, Heroku, Render, etc.), changes saved to `app_data.json` might be lost when the app restarts or redeploys, as these environments often use ephemeral file systems. For persistent data in a production environment, consider integrating with a proper database solution (e.g., SQLite, PostgreSQL, MongoDB, etc.).")


    elif admin_pass:
        st.warning("Incorrect Admin Password.")
    else:
        st.info("Enter admin password in the sidebar to access the admin panel.")

st.markdown("---")
st.caption("Powered by Google Gemini AI. Developed by Your Team.")